<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Custom Zoom and Scroll</title>
  <style>
    body {
      margin: 0;
      overflow: hidden; /* Prevent default scrollbars */
      font-family: Arial, sans-serif;
    }
    body{
      background-color: rgb(30, 30, 30);

    }

    .zoom-container {
      background-color: rgb(255, 255, 255);
      position: relative;
      z-index: 0;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      transform-origin: 0 0; /* Set origin for scaling */
    }
    .sticky{
      /* position: static; */
      position: fixed;
      z-index: 9999999;

      font-family : arial; font-size: 16px; background-color: rgb(44, 44, 44); color: rgb(228, 228, 228); text-align: center; vertical-align: middle; padding: 16px; margin: 0px; height: 100%; width: 15%; border-style:solid ; border-width:1px; border-radius: 0%;
      border-color: rgb(66, 66, 66);

    }
    .sticky1{
      /* position: static; */
      position: fixed;
      z-index: 9999999;
      right: 0;
      font-family : arial; font-size: 16px; background-color: rgb(44, 44, 44); color: rgb(228, 228, 228); text-align: center; vertical-align: middle; padding: 16px; margin: 0px; height: 100%; width: 15%; border-style:solid ; border-width:1px; border-radius: 0%;
      border-color: rgb(66, 66, 66);
    }
    .box {
            box-sizing: content-box;
            height: 500px;
            width: 500px;
            background-color: rgb(184, 184, 184);
            /* background-color: blue; */
            position: absolute;
            left: 50px;
            top: 50px;
            /* transform: translateX(-50%); */
        }
        


/*   /////////////////////////////////////////////////////////////////////// */
.header {
            width: 100%; /* The header spans the full width */
            min-height: 150px; /* Minimum height for the header */
            background-color: #ffffff; /* Light gray background for the header */
            padding: 20px; /* Padding inside the header */
            position: relative; /* Enables absolutely positioned children */
        }

        .draggable {
            position: absolute; /* Enables positioning within the parent container */
            cursor: grab; /* Shows the draggable cursor */
        }

        .draggable:active {
            cursor: grabbing; /* Change cursor while dragging */
        }

        .shape {
            background-color: #007BFF; /* Default blue background for shapes */
            color: white; /* White text color for contrast */
            display: flex; /* Flexbox for centering content */
            justify-content: center;
            align-items: center;
            text-align: center; /* Center text inside shapes */
        }

        textarea#output {
            width: 100%; /* Full-width textarea */
            height: 300px; /* Fixed height for the textarea */
            font-family: monospace; /* Monospace font for code readability */
            margin-top: 20px; /* Space above the textarea */
            font-size: 14px; /* Font size for the code */
            padding: 10px; /* Inner padding for better visibility */
            box-sizing: border-box; /* Include padding in width calculation */
        }

        #controls {
            margin-top: 20px; /* Space above the controls */
        }

        .context-menu {
            position: absolute; /* Context menu is absolutely positioned */
            display: none; /* Hidden by default */
            background-color: white; /* White background for visibility */
            border: 1px solid #ccc; /* Light border for separation */
            box-shadow: 0px 2px 5px rgba(0, 0, 0, 0.2); /* Subtle shadow for depth */
           /* Subtle shadow for depth */

            z-index: 1000; /* Ensures menu is on top of other elements */
            padding: 10px; /* Space inside the menu */
        }

        .context-menu input[type="color"] {
            margin-bottom: 5px; /* Space between inputs */
            width: 100%; /* Full-width color input */
        }

        .context-menu button {
            width: 100%; /* Full-width buttons */
            padding: 5px; /* Inner padding for buttons */
            margin-top: 5px; /* Space above each button */
        }


  </style>
</head>
<body>
  <div id="contextMenu" class="context-menu">
    <button onclick="bringToFront()">Bring to Front</button> <!-- New Button -->
    <button onclick="sendToBack()">Send to Back</button> <!-- New Button -->

    <button onclick="deleteElement()">Delete</button>
    <!-- Set the selected element as a parent -->
</div>
  <div class="sticky">layers 
    <div id="controls">
    <button onclick="addShape('circle')">Add Circle</button>
    <button onclick="addShape('square')">Add Square</button>
    <button onclick="addShape('rectangle')">Add Rectangle</button>
    <button onclick="addShape('triangle')">Add Triangle</button>
    <button onclick="addTextBox()">Add Text Box</button>
</div></div>
  <div class="sticky1">propertys

    <textarea id="output" readonly></textarea>

  </div>

  <div class="zoom-container" id="zoomContainer">
  <div id="headerPreview" class="header">
        <!-- Draggable and editable header title -->
        <h1 class="draggable" contenteditable="true" style="top: 10px; left: 50px; font-size: 24px; font-weight: bold;">Header Title</h1>
        <!-- Draggable and editable header subtitle -->
        <p class="draggable" contenteditable="true" style="top: 60px; left: 50px; font-size: 16px;">Header Subtitle</p>
    </div>

   
  
  </div>
  

  <!-- <script>
    const zoomContainer = document.getElementById('zoomContainer');
    let scale = 1; // Initial zoom scale
    let translateX = 0;
    let translateY = 0;

    let scrollX = 0; // Horizontal scroll position
    let scrollY = 0; // Vertical scroll position

    // Prevent default browser zoom behavior and handle custom zoom/scroll
    window.addEventListener('wheel', (event) => {
      if (event.ctrlKey) {
        event.preventDefault(); // Stop browser zoom
        customZoom(event); // Call custom zoom function
      } else {
        customScroll(event); // Handle vertical or horizontal scrolling
      }
    }, { passive: false }); // Allow preventDefault to work

    function customZoom(event) {
      // Calculate zoom factor
      const zoomFactor = event.deltaY < 0 ? 1.1 : 0.9;

      // Get cursor position relative to the zoom container
      const rect = zoomContainer.getBoundingClientRect();
      const cursorX = event.clientX - rect.left;
      const cursorY = event.clientY - rect.top;

      // Adjust scale and translation
      const newScale = scale * zoomFactor;
      translateX = cursorX - ((cursorX - translateX) * (newScale / scale));
      translateY = cursorY - ((cursorY - translateY) * (newScale / scale));
      scale = newScale;

      // Apply transformations
      zoomContainer.style.transform = `translate(${translateX- scrollX}px, ${translateY- scrollY}px) scale(${scale})`;
    }

    function customScroll(event) {
      event.preventDefault(); // Prevent default scroll behavior

      if (event.shiftKey) {
        // Shift + Scroll: Horizontal scrolling
        scrollX += event.deltaY;
      } else {
        // Normal Scroll: Vertical scrolling
        scrollY += event.deltaY;
      }

      // Apply scroll positions
      zoomContainer.style.transform = `
        translate(${translateX - scrollX}px, ${translateY - scrollY}px) scale(${scale})`;
    }
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Select the header preview and output text area
    const headerPreview = document.getElementById('headerPreview');
    const outputBox = document.getElementById('output');
    const contextMenu = document.getElementById('contextMenu');
    let targetElement = null; // Tracks the element being edited
    let parentElement = null; // Tracks the parent element
    let childElement = null; // Tracks the child element
    let zIndexCounter = 1000; // Initialize z-index counter

    // Update the output box with the generated HTML and inline CSS
    function updateOutput() {
        const elements = [...headerPreview.children];
        console.log('elements',elements)
        const headerContent = elements.map(el => {
            const clone = el.cloneNode(true); // Clone the element
            clone.removeAttribute('contenteditable'); // Remove editing capability
            clone.style.position = 'absolute'; // Retain absolute positioning
            return clone.outerHTML; // Convert to HTML string
        }).join('\n    ');
        console.log('headerCon',headerContent)

        const headerStyle = `
            width: 100%;
            min-height: 150px;
            background-color: #f4f4f4;
            padding: 20px;
            position: relative;
        `.trim();

        const generatedCode = `
<header style="${headerStyle}">
${headerContent}
</header>`;
        outputBox.value = generatedCode.trim(); // Display the code
    }

    

    function addTextBox() {
    const newTextBox = document.createElement('div'); // Create a new div
    newTextBox.classList.add('draggable'); // Add the draggable class
    newTextBox.style.position = 'absolute';
    newTextBox.style.top = '50px';
    newTextBox.style.left = '50px';
    newTextBox.style.width = '150px';
    newTextBox.style.height = '50px';
    newTextBox.style.border = '1px solid #000';
    newTextBox.style.backgroundColor = '#fff';
    newTextBox.style.color = '#000';
    newTextBox.style.padding = '10px';
    newTextBox.style.overflow = 'hidden';
    newTextBox.contentEditable = 'true'; // Make it editable

    makeDraggable(newTextBox); // Make the text box draggable
    headerPreview.appendChild(newTextBox); // Add to the preview
    updateOutput(); // Update the output code
}
    // Function to add a shape
    function addShape(type) {
        const newShape = document.createElement('div'); // Create a new div
        newShape.classList.add('draggable', 'shape'); // Add relevant classes
        newShape.style.position = 'absolute'; // Set initial position
        newShape.style.top = '50px';
        newShape.style.left = '50px';

        // Style the shape based on the type
        if (type === 'circle') {
            newShape.style.width = '50px';
            newShape.style.height = '50px';
            newShape.style.borderRadius = '50%'; // Make it a circle
            newShape.style.backgroundColor = 'blue';
        } else if (type === 'square') {
            newShape.style.width = '50px';
            newShape.style.height = '50px';
            newShape.style.backgroundColor = 'blue';
        } else if (type === 'rectangle') {
            newShape.style.width = '100px';
            newShape.style.height = '50px';
            newShape.style.backgroundColor = 'blue';
        } else if (type === 'triangle') {
            newShape.style.width = '0';
            newShape.style.height = '0';
            newShape.style.borderLeft = '25px solid transparent';
            newShape.style.borderRight = '25px solid transparent';
            newShape.style.borderBottom = '50px solid blue';
            newShape.style.backgroundColor = 'transparent';
            
        }

        makeDraggable(newShape); // Make the shape draggable
        headerPreview.appendChild(newShape); // Add to the preview
        updateOutput(); // Update the output code
    }

    // Function to make an element draggable
    function makeDraggable(el) {
    el.addEventListener('mousedown', function (event) {
        const rect = el.getBoundingClientRect();
        const startX = (event.clientX - rect.left) / scale; // Adjust for scale
        const startY = (event.clientY - rect.top) / scale; // Adjust for scale

        function onMouseMove(e) {
            // Calculate position considering scale and translations
            const newLeft = (e.clientX - startX * scale - translateX + scrollX) / scale;
            const newTop = (e.clientY - startY * scale - translateY + scrollY) / scale;

            el.style.left = `${newLeft}px`;
            el.style.top = `${newTop}px`;
            updateOutput(); // Update output to reflect the new position
        }

        function onMouseUp() {
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
        }

        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
    });

    // Show context menu on right-click
    el.addEventListener('contextmenu', function (event) {
        event.preventDefault(); // Prevent default menu
        targetElement = el; // Set the target element
        contextMenu.style.top = `${event.clientY}px`; // Position the menu
        contextMenu.style.left = `${event.clientX}px`;
        contextMenu.style.display = 'block'; // Show the menu
    });
}


    // Apply selected colors to the target element
    function applyColors() {
        if (targetElement) {
            const bgColor = document.getElementById('bgColor').value;
            const textColor = document.getElementById('textColor').value;
            targetElement.style.backgroundColor = bgColor;
            targetElement.style.color = textColor;
            contextMenu.style.display = 'none';
            updateOutput();
        }
    }


    // Hide the context menu when clicking outside
    document.addEventListener('click', function (e) {
        if (!contextMenu.contains(e.target)) {
            contextMenu.style.display = 'none';
        }
    });
    
    // zoomContainer.addEventListener('keydown',(event)=>{
    //   if(KeyboardEvent==)
    //     console.log( event.target)

      

    // })
    // Delete the selected element on Ctrl + Delete
    function deleteElement(){
    
        if (targetElement) {
            targetElement.remove(); // Remove the selected element
            targetElement = null; // Clear the reference
            contextMenu.style.display = 'none'; // Hide the context menu if visible
            updateOutput(); // Update the output code
        } else {
            console.log('No element selected to delete.');
        }
    }
    // Track the highest and lowest z-index values


// Function to bring an element to the front
function bringToFront() {
    if (targetElement) {
        zIndexCounter++; // Increment global z-index
        targetElement.style.zIndex = zIndexCounter; // Assign new z-index
        contextMenu.style.display = 'none'; // Hide context menu
        console.log(`Element brought to front with zIndex: ${zIndexCounter}`);
    } else {
        console.log("No element selected to bring to the front.");
    }
}

// Function to send an element to the back
function sendToBack() {
    if (targetElement) {
        targetElement.style.zIndex = 1; // Set a low z-index value
        contextMenu.style.display = 'none'; // Hide context menu
        console.log("Element sent to back with zIndex: 1");
    } else {
        console.log("No element selected to send to the back.");
    }
}


    

    // Make existing elements draggable
    document.querySelectorAll('.draggable').forEach(makeDraggable);

    // Update the output initially
    updateOutput();
</script> -->
<script src="/easyCss/dist/addElemetLogic.js"></script>
<script src="/easyCss/dist/propertyElementLogic.js"></script>
<script src="/easyCss/dist/zoomLogic.js"></script>
    <!-- <script src="/easyCss/dist/sizerLogic.js"></script> -->

</body>
</html>
